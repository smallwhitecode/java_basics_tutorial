# 一、类变量和类方法

![image-20250304210817743](面向对象(高级部分).assets/image-20250304210817743.png)

记住一点：static变量是对象共享，不管static变量在哪里，

共识**(1)：**static变量是同一个类所有对象共享

**（2）：**static类变量，在类加载的时候就生成了

- 什么是类变量

  类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。这个从前面的图也可以看出来

- 如何定义类变量

  定义语法：访问修饰符	static	数据类型	变量名；[推荐]

  ​					static	访问修饰符	数据类型	变量名；

- 如何访问类变量

  类名.类变量名或者 对象名.类变量名[静态变量的访问修饰符的访问权限和范围 和普通属性是一样的]

  推荐使用：类名.类变量名；

- 类变量使用注意事项和细节讨论

  1、什么时候需要用类变量：

  ​	当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量(静态变量)：比如：定义学生类，统计所有学生共交多少钱。

  2、类变量与实例变量(普通属性)区别

  ​	类变量是该类的所有对象共享的，而实例变量是每个对象独享的。

  3、加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量

  4、类变量可以同通过类名.类变量 或者 对象名.类变量名来访问，但java设计者推荐我们使用 类名.类变量吗方式访问。[前提是满足访问修饰符的访问权限和范围]

  5、实例变量不能通过类名.类变量访问

  6、类变量是在类加载时就初始化了，也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了

  7、类变量的生命周期时随类的加载开始，随着类消亡而销毁

- 类方法基本介绍

  类方法也叫静态方法

  形式如下：访问修饰符	static	数据返回类型	方法名(){} [推荐]

  ​					static	访问修饰符	数据返回类型	方法名(){}

- 类方法经典的使用场景

  - 当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率

    比如：工具类中的方法utils

    Math类、Arrays类、Collections集合类看下源码：

  - 小结：在程序员实际开发，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用了，比如打印一堆数组，冒泡排序，完成某个计算任务等

- 类方法使用注意事项和细节讨论

  1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：类方法中无this的参数

     ​						普通方法中隐含着this的参数

  2. 类方法可以通过类名调用，也可以通过对象名调用

  3. 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数)，不能通过类名调用

  4. 类方法中不允许使用和对象有关的关键字，比如this和supper。普通方法(成员方法)可以

  5. 类方法(静态方法)中 只能访问静态变量或静态方法

  6. 普通成员方法，即可以访问非静态成员，也可以访问静态成员

  小结：静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员(必须遵守访问权限)

# 二、理解main方法语法

- 深入理解main方法

  解释main方法的形式：**public** **static** void main(String[] args){}

  1. main方法是虚拟机调用
  2. java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public
  3. java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static
  4. 该方法接收String类型的数组参数，该数组 中保存执行java命令时传递给所运行的类的参数，案例演示
  5. java 执行的程序 参数1 参数2 参数3

### 特别提示：

1. 在main()方法中，我们可以直接调用main方法所在类的静态方法或静态属性
2. 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象区访问类中的非静态成员

# 三、代码块

- 基本介绍

  代码化块又称为**初始化块**，属于类中的成员[即 是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。

  但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。

- 基本语法

  [修饰符]{

  ​	代码

  };

  **说明注意：**

  1. 修饰符 可选，要写的话，也只能写static
  2. 代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块/非静态代码块
  3. 逻辑语句可以为任何逻辑语句(输入、输出、方法调用、循环、判断等)
  4. ；号可以写上，也可以省略

- 代码块的好处(个人理解)

  1. 相当于另外一种形式的构造器(对构造器的补充机制)，可以座初始化的操作
  2. 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性

- 代码块使用注意事项和细节讨论

  1. static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着**类的加载**而执行，并且**只会执行一次**。如果是普通代码块，每创建一个对象，就执行
  2. 类什么时候被加载
     1. 创建对象实例时(new)
     2. 创建子类对象实例，父类也会被加载
     3. 使用类的静态成员时(静态属性，静态方法)
  3. 普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行
  4. 创建一个对象时，在**一个类**调用顺序是：(**重点，难点**)
     1. 调用静态代码块和静态属性初始化(注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按定义的顺序调用)
     2. 调用普通代码块和普通属性初始化(注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用)
     3. 调用构造方法
  5. 构造器的最前面其实隐含了super()和调用普通代码块，新写一个类演示[截图+说明]，静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此是优先于构造器和普通代码块执行的
  6. 我们看一下创建一个子类对象时(继承关系)，他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：
     1. 父类的静态代码块和静态属性(优先级一样，按定义顺序执行)
     2. 子类的静态代码块和静态属性(优先级一样，按定义顺序执行)
     3. 子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
     4. 父类的构造方法
     5. 子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
     6. 子类的构造方法
  7. 静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任意成员

# 四、单例设计模式

- 什么是设计模式

  1. 静态方法和属性的经典属性
  2. 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像时经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己在思考和摸索

- 什么是单例模式：单例(单个的实例)

  1. 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法
  2. 单例模式有两种方式：(1)饿汉式    (2)懒汉式

- 单例模式应用实例

  演示饿汉式和懒汉式单例模式的实现

  步骤如下：

  1. 构造器私有化 =》 防止直接 new
  2. 类的内部创建对象
  3. 向外暴露一个静态的公共方法。getInstance
  4. 代码实现

- 饿汉式VS懒汉式

  1. 二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建。
  2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题。
  3. 饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题
  4. 在我们javaSE标准类中，java.lang.Runtime就是经典的单例模式

# 五、final关键字

## 1、基本介绍

final中文意思：最后的，最终的

final可以修饰类、属性、方法和局部变量。

在某些情况下，程序员可能有以下需求，就会使用final

1. 当不希望类被继承时，可以用final修饰
2. 当不希望父类的某个方法被子类覆盖/重写(Override)时，可以用final关键字修饰
3. 当不希望类的某个属性的值被修改，可以用final修饰
4. 当不希望某个局部变量被修改，可以使用final修饰

## 2、final使用注意事项和细节讨论

1. final修饰的属性又叫常量，一般用XX_XX_XX来命名

2. final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一[选择一个位置赋初值即可]：

   1. 定义时：如public final double TAX_RATE = 0.08;
   2. 在构造器中
   3. 在代码块中

3. 如果final修饰的属性是静态的，则初始化的位置只能是

   1、定义时	2、在静态代码块  不能在构造器中赋值

4. final类不能继承，但是可以实例化对象

5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承

6. 一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法

7. final不能修饰构造方法(即构造器)

8. final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理

9. 包装类(Integer，Double，Float，Boolean等都是final)，String也是final类

# 六、抽象类

当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类

## 1、解决之道-抽象类快速入门

当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类

## 2、抽象类的介绍

1. 用abstract关键字来修饰一个类时，这个类就叫抽象类

   访问修饰符	abstract	类名{

   }

2. 用abstract关键字来修饰一个方法时，这个方法就是抽象方法

   访问修饰符	abstract	返回类型	方法名(参数列表)；//没有方法体

3. 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类

4. 抽象类，是考官比较爱问的知识点，在框架和设计模式使用较多

## 3、抽象类使用的注意事项和细节讨论

1. 抽象类不能被实例化
2. 抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法，还可以有实现的方法
3. 一旦类包含了abstract方法，则这个类必须声明为abstract
4. abstract只能修饰类和方法，不能修饰属性和其他
5. 抽象类可以有任意成员[**抽象类本质还是类**]，比如：非抽象方法、构造器、静态属性等
6. 抽象方法不能有主体，即不能实现
7. 如果一个类继承了抽象类，则它必须实现抽象类的所有方法，除非它自己也声明了abstract类
8. 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的

## 4、抽象类最佳实践-模板设计模式

- 最佳实践

# 七、接口

## 1、基本介绍

接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。

语法：

interface 接口名{

​	//属性

​	//方法（1、抽象方法，2、默认实现方法，3、静态方法）

}

class 类名 implements 接口{

​		自己属性；

​		自己方法；

​		必须实现的接口的抽象方法

}

小结：1、在jdk7.0前 接口里的所有方法都没有方法体，即都是抽象方法。

​			2、jdk8.0后接口可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现

![image-20250316233207820](面向对象(高级部分).assets/image-20250316233207820.png)

## 2、注意事项和细节

1. 接口不能被实例化

2. 接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰 图示：

   ![image-20250317200117753](面向对象(高级部分).assets/image-20250317200117753.png)

3. 一个普通类实现接口，就必须将该接口的所有方法都实现

4. 抽象类实现接口，可以不用实现接口的方法

5. 一个类同时可以实现多个接口

6. 接口中的属性，只能是final的，而且是public static final 修饰符。比如：int a = 1;实际上是public static final int a = 1;(必须初始化)

7. 接口中属性的访问形式：接口名.属性名

8. 一个接口不能继承其他的类，但是可以继承多个别的接口

9. 接口的修饰符 只能是public和默认，这点和类的修饰符是一样的

## 3、实现接口VS继承类

当子类继承了父类，就会自动的拥有父类的功能

如果子类需要扩展功能，可以通过实现接口的方式扩展

可以理解 实现接口 是 对java 单继承机制的一种补充

1. 接口和继承解决的问题不同

   继承的价值主要在于：解决代码的复用性和可维护性

   接口的价值主要在于：设计，设计好各种规范(方法)，让其它类去实现这些方法

2. 接口比继承更加灵活

   接口比继承更加灵活，继承是满足is-a 的关系，而接口只需满足like - a的关系

3. 接口在一定程度上实现代码解耦[即：接口规范性+动态绑定机制]

## 4、接口的多态特性

1. 多态参数(前面案例体现)

   在前面Usb接口案例，UsbInterface usbInterface，即可以接收手机对象，又可以接收相机对象，就体现了 接口多态(接口引用可以指向实现了接口的类的对象)

2. 多态数组 InterfacePolyArr.java

3. 接口存在**多态传递**现象 InterfacePolyPass.java

![image-20250317212456950](面向对象(高级部分).assets/image-20250317212456950.png)

# 八、内部类

## 1、基本介绍

一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)。是我们类的第五大成员[思考：类的五大成员又有哪些]，内部类最大的特点就是可以直接访问私有属性，并且可以体现类于类之间的包含关系

## 2、内部类的分类

- 定义在外部类局部位置上(比如方法内)：

  1. 局部内部类(有类名)
  2. 匿名内部类(没有类名，重点)

- 定义在外部类的成员位置上：

  1. 成员内部类(没有static修饰)
  2. 静态内部类(使用static修饰)

  #### 1、局部内部类的使用 LocalInnerClass.java

  说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名。

  1. 可以直接访问外部类的所有成员，包含私有的

  2. 不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final

  3. 作用域：仅仅在定义它的方法或代码块中。

  4. 局部内部类--访问--->外部类的成员[访问方式：直接访问]

  5. 外部类---访问--->局部内部类的成员

     访问方式：创建对象，在访问(注意：必须在作用域中)

  6. 外部其他类---不能访问---->局部内部类(因为 局部内部类地位是一个局部变量)

  7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问

  #### 2、匿名内部类的使用(重要)

  说明：匿名内部类时定义在外部类的局部位置，比如方法中，并且没有类名

  1. 匿名内部类的基本语法

     new 类或接口(参数列表){

     ​	类体

     };

  2. 匿名内部类的语法比较奇特，请大家注意，因为匿名内部类即是一个类的定义，同时它本身也是一个对象，因此从语法上看，它即有定义类的特征，也有创建对象的特征，对前面代码分析可以看出这个特点，因此可以调用匿名内部类方法

  3. 可以直接访问外部类的所有成员，包含私有的

  4. 不能添加访问修饰符，因为它的地位就是一个局部变量

  5. 作用域：仅仅在定义它的方法或代码块中

  6. 匿名内部类--访问--->外部类成员[访问方式：直接访问]

  7. 外部其他类---不能访问---->匿名内部类(因为 匿名内部类地位是一个局部变量)

  8. 如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问

  #### 3、成员内部类的使用

  说明：成员内部类是定义在外部类的成员位置，并且没有static修饰

  1. 可以直接访问外部类的所有成员，包含所有的

  2. 可以添加任意访问修饰符(public、protected、默认、private)，因为它的地位就是一个成员

  3. 作用域：和外部类的其他成员一样，为整个类体。比如前面案例，在外部类的成员方法中创建成员内部类，在调用方法。

  4. 成员内部类---访问--->外部类(比如：属性)[访问方法：直接访问]

  5. 外部类---访问--->成员内部类

     访问方式：创建对象，再访问

  6. 外部其他类---访问--->成员内部类![image-20250319213118771](面向对象(高级部分).assets/image-20250319213118771.png)

  7. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员) 去访问

  #### 4、静态内部类的使用

  说明：静态内部类是定义在外部类的成员位置，并且有static修饰

  1. 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员
  2. 可以添加任意访问修饰符(public、protected、默认、private)，因为它的地位就是一个成员
  3. 作用域：同其他的成员，为整个类体
  4. 静态内部类---访问--->外部类(比如：静态属性)[访问方式：直接访问所有静态成员]
  5. 外部类---访问--->静态内部类 访问方式：创建对象，再访问
  6. 外部其他类---访问--->静态内部类
  7. 如果外部类和静态内部类的成员重名时，静态内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.成员) 去访问

