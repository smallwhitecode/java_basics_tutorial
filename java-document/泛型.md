# 一、泛型的理解和好处

## 1、使用传统方法的问题分析

1. 不能对加入到集合ArrayList中的数据类型进行约束(不安全)
2. 遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响

## 2、泛型的好处

1. 编译时，检查添加元素的类型，提高了安全性

2. 减少了类型转换的次数，提高效率

   - 不使用泛型

     Dog-加入>Object -取出>Dog //放入到ArrayList会先转成Object，在取出时，还需要转换成Dog

   - 使用泛型

     Dog->Dog->Dog//放入时，和取出时，不需要类型转换，提高效率

3. 不再提示编译警告

# 二、泛型介绍

int a =10;

泛(广泛)型(类型) => Integer，String，Dog

1. 泛型又称参数化类型，是Jdk5.0 出现的新特性，解决数据类型的安全性问题
2. 在类声明或实例化时只要指定好需要的具体的类型即可
3. Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮
4. 泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型

# 三、泛型的语法

## 1、泛型的声明

interface 接口<T>{}和class类 <K，V>{}

//比如：List，ArrayList

说明：

1. 其中，T，K，V不代表值，而是表示类型
2. 任意字母都可以。常用T表示，是Type的缩写

## 2、泛型的实例化

要在类名后面指定类型参数的值(类型)。如：

1. List<String> strList = new ArrayList<String>（）；
2. Iterator<Customer> iterator = customers.iterator（）;

## 3、泛型语法和使用

举例说明，泛型在HashSet，HashMap的使用情况，演示GenericExercise.java

## 4、泛型使用的注意事项和细节

1. interface List<T>{}，public class HashSet<E>{}..等等

   说明：T，E只能是引用类型

2. 在指定泛型具体类型后，可以传入该类型或者其子类类型

3. 泛型使用形式

   ![image-20250420231636877](泛型.assets/image-20250420231636877.png)

4. 如果我们这样写 List list3 = new ArrayList();默认给它的泛型是[<E> E就是Object]

# 四、自定义泛型类

## 1、自定义泛型类

1. 基本语法

   class 类名<T,R...>{//...表示可以有多个泛型

   ​	成员

   }

2. 注意细节

   - 普通成员可以使用泛型(属性、方法)
   - 使用泛型的数组，不能初始化
   - 静态方法中不能使用类的泛型
   - 泛型类的类型，是在创建对象时确定的(因为创建对象时，需要指定确定类型)
   - 如果在创建对象时，没有指定类型，默认为Object

## 2、自定义泛型接口

1. 基本语法

   interface 接口名<T,R...>{

   }

2. 注意细节

   - 接口中，静态成员也不能使用泛型(这个和泛型类规定一样)
   - 泛型接口的类型，在**继承接口**或者**实现接口**时确定
   - 没有指定类型，默认为Object

## 3、自定义泛型方法

1. 基本语法

   修饰符 <T，R...> 返回类型 方法名(参数列表){

   }

2. 注意细节

   - 泛型方法，可以定义在普通类中，也可以定义在泛型类中
   - 当泛型方法被调用时，类型会确定
   - public void eat(E e){}，修饰符后没有<T，R...> eat方法不是泛型方法，而是使用了泛型

# 五、泛型的继承和通配符

## 1、泛型的继承和通配符说明

1. 泛型不具备继承性

   List<Object> list = new ArrayList<String>();//错误

2. <?>：支持任意泛型类型

3. <？extends A>：支持A类以及A类的子类，规定了泛型的上限

4. <？super A>：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限